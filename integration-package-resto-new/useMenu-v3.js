/**
 * üé£ HOOKS PARA MENU SDK v3.0 - Basado en la implementaci√≥n de Groove
 * Hooks de React actualizados con todo lo aprendido del proyecto real
 * 
 * SOPORTE: Estructura legacy y m√∫ltiples men√∫s
 * FEATURES: Real-time updates, terminolog√≠a din√°mica, validaci√≥n de stock
 */

import { useState, useEffect, useCallback, useRef } from 'react';

/**
 * üìã Hook principal para usar el men√∫ (compatible con legacy)
 * @param {MenuSDK} menuSDK - Instancia del MenuSDK
 * @returns {Object} - Estado del men√∫ con business info, men√∫ y loading states
 */
export function useMenu(menuSDK) {
  const [business, setBusiness] = useState(null);
  const [restaurant, setRestaurant] = useState(null); // Mantener para compatibilidad
  const [menu, setMenu] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!menuSDK) return;

    let unsubscribeBusinessInfo = null;

    async function loadData() {
      try {
        setLoading(true);
        setError(null);
        
        // Cargar men√∫ una vez
        const menuData = await menuSDK.getFullMenu();
        setMenu(menuData);

        // Configurar listener en tiempo real para informaci√≥n del negocio
        unsubscribeBusinessInfo = menuSDK.onBusinessInfoChange((businessData, error) => {
          if (error) {
            setError(error.message);
            console.error('Error in business info listener:', error);
          } else if (businessData) {
            setBusiness(businessData);
            setRestaurant(businessData); // Para compatibilidad con c√≥digo existente
          } else {
            setBusiness(null);
            setRestaurant(null);
            setError('Business not found');
          }
        });

      } catch (err) {
        setError(err.message);
        console.error('Error loading menu:', err);
      } finally {
        setLoading(false);
      }
    }

    loadData();

    // Cleanup function
    return () => {
      if (unsubscribeBusinessInfo) {
        unsubscribeBusinessInfo();
      }
    };
  }, [menuSDK]);

  return { 
    business, 
    restaurant, // Mantener para compatibilidad
    menu, 
    loading, 
    error 
  };
}

/**
 * üçΩÔ∏è Hook para obtener m√∫ltiples men√∫s disponibles (nueva funcionalidad)
 * @param {MenuSDK} menuSDK - Instancia del MenuSDK
 * @returns {Object} - Lista de men√∫s disponibles y loading states
 */
export function useGrooveMenus(menuSDK) {
  const [menus, setMenus] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!menuSDK) {
      setLoading(false);
      return;
    }

    async function loadMenus() {
      try {
        setLoading(true);
        setError(null);
        
        console.log('üçΩÔ∏è Loading available menus...');
        const availableMenus = await menuSDK.getAvailableMenus();
        
        if (availableMenus.length === 0) {
          // Fallback a estructura legacy
          const legacyMenu = await menuSDK.getFullMenu();
          if (legacyMenu.length > 0) {
            setMenus([{
              id: 'default',
              name: 'Men√∫ Principal',
              description: 'Men√∫ del restaurante',
              categories: legacyMenu
            }]);
          }
        } else {
          setMenus(availableMenus);
        }
        
        console.log('‚úÖ Menus loaded:', availableMenus.length);
      } catch (err) {
        console.error('‚ùå Error loading menus:', err);
        setError(err.message || 'Error loading menus');
      } finally {
        setLoading(false);
      }
    }

    loadMenus();
  }, [menuSDK]);

  return { menus, loading, error };
}

/**
 * üéØ Hook para obtener categor√≠as y items de un men√∫ espec√≠fico
 * @param {MenuSDK} menuSDK - Instancia del MenuSDK
 * @param {string} menuType - Tipo/ID del men√∫ a cargar
 * @returns {Object} - Categor√≠as e items del men√∫ seleccionado
 */
export function useMenuCategories(menuSDK, menuType) {
  const [categories, setCategories] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!menuSDK || !menuType) {
      setLoading(false);
      return;
    }

    async function loadCategories() {
      try {
        setLoading(true);
        setError(null);
        
        console.log('üéØ Loading categories for menu:', menuType);
        
        // Intentar cargar como men√∫ espec√≠fico
        try {
          const menuData = await menuSDK.getMenuById(menuType);
          setCategories(menuData.categories || []);
          console.log('‚úÖ Categories loaded for menu:', menuType, menuData.categories?.length);
        } catch (menuError) {
          // Fallback: usar getFullMenu si falla getMenuById
          console.log('üìù Fallback to getFullMenu');
          const legacyMenu = await menuSDK.getFullMenu();
          setCategories(legacyMenu);
          console.log('‚úÖ Legacy menu loaded:', legacyMenu.length);
        }
        
      } catch (err) {
        console.error('‚ùå Error loading categories:', err);
        setError(err.message || 'Error loading categories');
      } finally {
        setLoading(false);
      }
    }

    loadCategories();
  }, [menuSDK, menuType]);

  return { categories, loading, error };
}

/**
 * üõí Hook para manejar carrito con validaci√≥n de stock
 * @param {MenuSDK} menuSDK - Instancia del MenuSDK para validar stock
 * @returns {Object} - Estado del carrito y funciones para manipularlo
 */
export function useCart(menuSDK = null) {
  const [cart, setCart] = useState([]);
  const [validationErrors, setValidationErrors] = useState([]);

  const addToCart = useCallback(async (item, quantity = 1) => {
    try {
      // Validar stock si tenemos SDK
      if (menuSDK) {
        const stockValidation = menuSDK.validateStock(item, quantity);
        if (!stockValidation.isValid) {
          console.warn('Stock validation failed:', stockValidation.message);
          setValidationErrors(prev => [...prev, {
            itemId: item.id,
            message: stockValidation.message
          }]);
          return false;
        }
      }

      setCart(prevCart => {
        const existingItemIndex = prevCart.findIndex(cartItem => cartItem.id === item.id);
        
        if (existingItemIndex > -1) {
          // Actualizar cantidad del item existente
          const newCart = [...prevCart];
          newCart[existingItemIndex] = {
            ...newCart[existingItemIndex],
            quantity: newCart[existingItemIndex].quantity + quantity
          };
          return newCart;
        } else {
          // Agregar nuevo item
          return [...prevCart, {
            ...item,
            quantity: quantity,
            addedAt: new Date().toISOString()
          }];
        }
      });

      // Limpiar errores de validaci√≥n para este item
      setValidationErrors(prev => prev.filter(error => error.itemId !== item.id));
      
      console.log('‚úÖ Item added to cart:', item.name, 'qty:', quantity);
      return true;
    } catch (error) {
      console.error('‚ùå Error adding to cart:', error);
      return false;
    }
  }, [menuSDK]);

  const removeFromCart = useCallback((itemId) => {
    setCart(prevCart => prevCart.filter(item => item.id !== itemId));
    // Limpiar errores de validaci√≥n para este item
    setValidationErrors(prev => prev.filter(error => error.itemId !== itemId));
    console.log('üóëÔ∏è Item removed from cart:', itemId);
  }, []);

  const updateQuantity = useCallback(async (itemId, quantity) => {
    if (quantity <= 0) {
      removeFromCart(itemId);
      return;
    }

    setCart(prevCart => {
      const newCart = prevCart.map(item => 
        item.id === itemId 
          ? { ...item, quantity: quantity }
          : item
      );
      
      // Validar stock para el item actualizado si tenemos SDK
      if (menuSDK) {
        const cartItem = newCart.find(item => item.id === itemId);
        if (cartItem) {
          const stockValidation = menuSDK.validateStock(cartItem, quantity);
          if (!stockValidation.isValid) {
            setValidationErrors(prev => [...prev.filter(e => e.itemId !== itemId), {
              itemId: itemId,
              message: stockValidation.message
            }]);
          } else {
            setValidationErrors(prev => prev.filter(e => e.itemId !== itemId));
          }
        }
      }
      
      return newCart;
    });
    
    console.log('üîÑ Cart quantity updated:', itemId, 'new qty:', quantity);
  }, [menuSDK, removeFromCart]);

  const clearCart = useCallback(() => {
    setCart([]);
    setValidationErrors([]);
    console.log('üßπ Cart cleared');
  }, []);

  const validateCartStock = useCallback(async () => {
    if (!menuSDK || cart.length === 0) return { isValid: true, errors: [] };

    try {
      const validation = await menuSDK.validateCart(cart);
      setValidationErrors(validation.errors || []);
      return validation;
    } catch (error) {
      console.error('‚ùå Error validating cart:', error);
      return { isValid: false, errors: [{ message: 'Error validating cart' }] };
    }
  }, [menuSDK, cart]);

  // Calcular totales
  const cartTotal = cart.reduce((total, item) => total + (item.price * item.quantity), 0);
  const cartCount = cart.reduce((total, item) => total + item.quantity, 0);

  return {
    cart,
    addToCart,
    removeFromCart,
    updateQuantity,
    clearCart,
    cartTotal,
    cartCount,
    validationErrors,
    validateCartStock
  };
}

/**
 * ‚≠ê Hook para obtener solo platos destacados
 * @param {MenuSDK} menuSDK - Instancia del MenuSDK
 * @returns {Object} - Items destacados y loading states
 */
export function useFeaturedItems(menuSDK) {
  const [featuredItems, setFeaturedItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!menuSDK) {
      setLoading(false);
      return;
    }

    async function loadFeaturedItems() {
      try {
        setLoading(true);
        setError(null);
        
        console.log('‚≠ê Loading featured items...');
        const featured = await menuSDK.getFeaturedItems();
        setFeaturedItems(featured);
        console.log('‚úÖ Featured items loaded:', featured.length);
      } catch (err) {
        console.error('‚ùå Error loading featured items:', err);
        setError(err.message || 'Error loading featured items');
      } finally {
        setLoading(false);
      }
    }

    loadFeaturedItems();
  }, [menuSDK]);

  return { featuredItems, loading, error };
}

/**
 * üé® Hook para obtener terminolog√≠a din√°mica basada en el tipo de negocio
 * @param {string} businessType - Tipo de negocio ('restaurant', 'store', etc.)
 * @returns {Object} - Objeto con terminolog√≠a adaptada
 */
export function useBusinessTerminology(businessType = 'restaurant') {
  const terminology = {
    restaurant: {
      menuSingular: 'men√∫',
      menuPlural: 'men√∫s',
      itemSingular: 'plato',
      itemPlural: 'platos',
      categorySingular: 'categor√≠a',
      categoryPlural: 'categor√≠as',
      cartName: 'pedido',
      addToCartText: 'Agregar al pedido',
      businessType: 'Restaurante'
    },
    store: {
      menuSingular: 'cat√°logo',
      menuPlural: 'cat√°logos',
      itemSingular: 'producto',
      itemPlural: 'productos',
      categorySingular: 'categor√≠a',
      categoryPlural: 'categor√≠as',
      cartName: 'carrito',
      addToCartText: 'Agregar al carrito',
      businessType: 'Tienda'
    },
    bakery: {
      menuSingular: 'men√∫',
      menuPlural: 'men√∫s',
      itemSingular: 'producto',
      itemPlural: 'productos',
      categorySingular: 'categor√≠a',
      categoryPlural: 'categor√≠as',
      cartName: 'pedido',
      addToCartText: 'Agregar al pedido',
      businessType: 'Panader√≠a'
    }
  };

  return terminology[businessType] || terminology.restaurant;
}

/**
 * üè™ Hook combinado que incluye men√∫ y terminolog√≠a autom√°tica
 * @param {MenuSDK} menuSDK - Instancia del MenuSDK
 * @returns {Object} - Estado completo del men√∫ con terminolog√≠a
 */
export function useMenuWithTerminology(menuSDK) {
  const menuState = useMenu(menuSDK);
  const businessType = menuState.business?.businessType || 'restaurant';
  const terminology = useBusinessTerminology(businessType);

  return {
    ...menuState,
    terminology,
    businessType
  };
}

/**
 * üîç Hook para b√∫squeda de items
 * @param {MenuSDK} menuSDK - Instancia del MenuSDK
 * @param {string} searchTerm - T√©rmino de b√∫squeda
 * @returns {Object} - Resultados de b√∫squeda y estados
 */
export function useMenuSearch(menuSDK, searchTerm) {
  const [searchResults, setSearchResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!menuSDK || !searchTerm || searchTerm.trim().length < 2) {
      setSearchResults([]);
      setLoading(false);
      return;
    }

    async function performSearch() {
      try {
        setLoading(true);
        setError(null);
        
        console.log('üîç Searching for:', searchTerm);
        const results = await menuSDK.searchItems(searchTerm);
        setSearchResults(results);
        console.log('‚úÖ Search completed:', results.length, 'results');
      } catch (err) {
        console.error('‚ùå Search error:', err);
        setError(err.message || 'Error searching items');
      } finally {
        setLoading(false);
      }
    }

    const debounceTimer = setTimeout(performSearch, 300);
    
    return () => clearTimeout(debounceTimer);
  }, [menuSDK, searchTerm]);

  return { searchResults, loading, error };
}

// Exports para compatibilidad con versiones anteriores
export { useMenu as useMenuLegacy };
export { useCart as useCartLegacy };
